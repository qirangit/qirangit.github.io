<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>javascript | Robot Qi Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="js介绍 网景公司95年发明了js，用于浏览器中的网页动态交互，ECMAScript是其语言标准，而js则是它的实现，类似的实现还有微软的jscript，目前较新的ECMA标准是ES6，需要掌握  js是一门弱类型、动态类型和动态的语言，其typecheck发生在运行期，其变量的类型不固定，可以变换，其语言的结构比如对象的字段和方法可以动态增删  js代码可以镶嵌在html网页中的任何地方，可以使">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript">
<meta property="og:url" content="http://www.robotqi.cn/2020/05/05/javascript/index.html">
<meta property="og:site_name" content="Robot Qi Blog">
<meta property="og:description" content="js介绍 网景公司95年发明了js，用于浏览器中的网页动态交互，ECMAScript是其语言标准，而js则是它的实现，类似的实现还有微软的jscript，目前较新的ECMA标准是ES6，需要掌握  js是一门弱类型、动态类型和动态的语言，其typecheck发生在运行期，其变量的类型不固定，可以变换，其语言的结构比如对象的字段和方法可以动态增删  js代码可以镶嵌在html网页中的任何地方，可以使">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-05T06:28:14.000Z">
<meta property="article:modified_time" content="2020-05-10T09:23:01.533Z">
<meta property="article:author" content="Robot Qi">
<meta property="article:tag" content="javascript&#x2F;node.js">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Robot Qi Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Robot Qi Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.robotqi.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-javascript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/05/javascript/" class="article-date">
  <time datetime="2020-05-05T06:28:14.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      javascript
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="js介绍"><a href="#js介绍" class="headerlink" title="js介绍"></a>js介绍</h3><ol>
<li><p>网景公司95年发明了js，用于浏览器中的网页动态交互，ECMAScript是其语言标准，而js则是它的实现，类似的实现还有微软的jscript，目前较新的ECMA标准是ES6，需要掌握</p>
</li>
<li><p>js是一门弱类型、动态类型和动态的语言，其typecheck发生在运行期，其变量的类型不固定，可以变换，其语言的结构比如对象的字段和方法可以动态增删</p>
</li>
<li><p>js代码可以镶嵌在html网页中的任何地方，可以使用<code>&lt;script&gt;</code>标签下直接包裹js代码，也可以通过 <code>&lt;script&gt;</code>标签的src属性来引入js文件，<strong>又或者是通过link引入代码</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">'Hello, world'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">-----------分割线-----------</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/js/abc.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="js基础知识"><a href="#js基础知识" class="headerlink" title="js基础知识"></a>js基础知识</h3></li>
<li><p>基本常识</p>
<ol>
<li>js与go类似，语句末尾可以不加分号，其有语法糖可以自动添加，但是由于不像go对格式有着强校验，所以可能错误添加分号，导致歧义，所以个人建议还是与java一样显式添加分号，降低心智负担</li>
<li>js的注释与java一致，单行使用<code>// 注释语句</code>，多行使用<code>/* 注释语句 */</code></li>
</ol>
</li>
<li><p>数据类型</p>
<ol>
<li><p>数值类型Number，不区分整数与浮点数，另外有两个特殊的数值类型</p>
<ul>
<li>NaN(not a number)表示无法计算的结果，比如0/0</li>
<li>Infinity(无限大)，表示超出Number类型的最大值，比如1/0</li>
</ul>
</li>
<li><p>字符串类型String</p>
<ol>
<li><p>使用单引号或者双引号围起来，两者没有区别，对于多行换行可以使用转义字符<code>\n</code>，也支持使用使用反引号`围起来，快速换行</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下述两种方式都能实现换行</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"hello\nworld"</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持<code>+</code>加号重载，类似java可以连接字符串与其他数据类型，同时ES6提供模板字符串，也就是占位符，字符串需要使用反引号</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"今年"</span>+age+<span class="string">"岁"</span>;</span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">`今年<span class="subst">$&#123;age&#125;</span>岁`</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>js中的字符串与java和go一致，都是属于不可变的，字符串作为高频操作的对象，其内置了很多处理方法</p>
<ol>
<li><p>length，获取字符串的长度，注意这是一个属性，并不是一个方法，返回的是字符数，这是与java一致的，并且类似于go可以通过类似数组下标的方式访问字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"张三zhangsan"</span>;</span><br><span class="line">str.length;<span class="comment">// 10</span></span><br><span class="line">str[<span class="number">2</span>];<span class="comment">// z</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与其他语言一样，常见的大小写转换、trim、substring(可用slice取代)、startsWith等方法一应俱全，具体参考api</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello WORLD"</span>;</span><br><span class="line">str.slice(<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>布尔值类型Boolean</p>
<ol>
<li><p>其值为true和false，不同于java与go中的严谨，js与python一样，对于数值类型中的0、0.0、NaN、空字符串””、两个特殊的类型null和undefined都被视为false，注意Infinity是true，这会方便于进行if判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="number">0</span> &amp;&amp; !<span class="number">0.0</span> &amp;&amp; !<span class="string">""</span> &amp;&amp; !<span class="literal">NaN</span> &amp;&amp; !<span class="literal">null</span> &amp;&amp; !<span class="literal">undefined</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"以上都视作为false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">Infinity</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Infinity视作为true"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>对象类型Object</p>
<p> ​    1. null、数组和普通对象都是Object类型，这个null表示空，类似于java中的null、go中的nil、python中的None</p>
</li>
<li><p>未定义undefined</p>
<pre><code>1. 不同于java与go，js还有undefined表示未定义，顾名思义，比如没有定义的属性，没有传递的值等</code></pre></li>
</ol>
</li>
<li><p>常见的对象类型</p>
<ol>
<li><p>数组</p>
<ol>
<li><p>js中的数组类似于python中的列表，可以存储任意类型的元素包括数组，创建方式有两种</p>
<ul>
<li>一种是<code>[1,NaN,Infinity,null,undefined,&quot;a&quot;,true]</code></li>
<li>另一种使用new的方式，<code>new Array(1,NaN,Infinity,null,undefined,&quot;a&quot;,true)</code></li>
</ul>
</li>
<li><p>类似于字符串，数组也内置了很多属性与方法，使用length属性获取数组长度，还有诸如indexOf、sort、reverse、concat、join、slice等方法，其中slice方法类似于String中的slice，同样其返回的是一个新的数组，如果不传递参数则是复制，更多参考api</p>
</li>
<li><p>对于数组的扩缩容，类似于python中对于列表的append和delete</p>
<ul>
<li>使用push和pop，在数组末尾添加或删除元素</li>
<li>使用unshift和shift，在数组开头添加或删除元素</li>
<li>最强大的扩缩容方法就是splice，可以删可以增，其有三个参数，比如<code>arr.splice(2,3,&quot;a&quot;)</code>，表示在arr数组的第二个索引开始删除3个元素，并插入”a”元素，该方法可以拓展表示只添加不删除或者只删除不添加</li>
</ul>
</li>
<li><p>js中数组非常“灵活”，其表现在以下三个方面，不建议使用以下糟粕，了解即可</p>
<ul>
<li>数组的长度不仅可以获取，还能赋值，在对数组长度进行赋值的时候，会使得数组进行自动扩容或者缩容</li>
<li>数组可以越界访问，此时数组也会自动扩容，</li>
<li>允许<code>arr[&quot;name&quot;]=2</code>这种操作，此时该角标变成字符串，并且数组length并不会发生改变(for in循环会遍历此元素，而for of循环不会遍历此元素)</li>
</ul>
</li>
</ol>
</li>
<li><p>对象</p>
<ol>
<li><p>在ES6之前，创建一个js的对象不需要像java这种需要先定义类，再创建对象，它是直接创建出对象，另外其属性也没有所谓的类型和权限修饰符等概念。js使用键值对直接描述对象(类似于map，这就是对象的本质)，js对象的键也就是属性都是字符串类型，值可以是任意类型，其属性可以不用双引号包裹，但对于属性名称中有特殊字符的，需要使用双引号包裹</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    name:<span class="string">"张三"</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    isChinese:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">"location-address"</span>:<span class="string">"SHA"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问对象的属性时，直接通过点号<code>.</code>比如<code>person.name</code>，这里的属性不添加双引号，另外还提供下标访问的方式<code>person[&quot;name&quot;]</code>，此时需要添加双引号。对于含有特殊字符的属性，需要使用双引号包裹，所以只能使用下标方式访问比如<code>person[&quot;location-address&quot;]</code>。对于访问不存在的对象字段，返回为undefined，并不会报错</p>
</li>
<li><p>js是动态语言，可以动态地增加或者删除属性，比如添加一个不存在的female属性，<code>p.female=true</code>，删除一个已有的属性，<code>delete p.female</code>或者<code>delete p[&quot;female&quot;]</code>，删除不存在的字段不会报错</p>
</li>
<li><p>js对象继承于Object类，所以会继承到toString等属性</p>
<ul>
<li>判断一个属性是否属于一个对象，使用<code>in</code>关键字，比如<code>var exist=&quot;name&quot; in p</code></li>
<li>判断一个属性是否属于一个对象自身拥有，使用<code>hasOwnProperty</code>，比如<code>var exist=p.hasOwnProperty(&quot;name&quot;)</code></li>
</ul>
</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li>js的对象就可以表示map类型，其格式与python一致，但是这种方式的问题在于键必须是字符串类型，所以ES6新增了Map对象</li>
<li>创建Map对象的时候可以进行初始化，比如<code>var m=new Map([[&quot;zhangsan&quot;,10],[true,2],[1,10]])</code>，这个初始化的格式需要注意使用的是二维数组</li>
<li>Map对象的增删改查方法<ul>
<li>使用set方法插入键值对，比如<code>m.set(&quot;hello&quot;,2)</code></li>
<li>使用delete方法进行删除，比如<code>m.delete(&quot;hello&quot;)</code></li>
<li>使用get方法获取值，比如<code>m.get(&quot;hello&quot;)</code>，对于不存在的键值对返回undefined，使用has方法判断有无键值对，比如<code>m.has(&quot;wawngwu&quot;)</code></li>
<li>另外也支持keys和values方法获取键集和值集</li>
</ul>
</li>
<li>ES6也提供了Set对象，其拥有add、delete、has等方法</li>
</ol>
</li>
</ol>
</li>
<li><p>变量</p>
<ol>
<li><p>js中声明一个变量使用<code>var</code>关键字，由于js是弱类型语言，所以变量的类型不固定可以发生变化，声明时不需要指定数据类型，另外声明后如果不初始化，值为undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">a=<span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> c;<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这里讲述一个js的一个缺陷，如之前所述使用<code>var</code>关键字来声明变量，但是其实可以不使用该关键字直接使用变量，在函数外这种方式并没有什么影响，但在js的函数内如果不使用<code>var</code>声明直接使用变量，这种变量的作用域也是全局的，而如果使用<code>var</code>声明，则变量的作用域就是函数内，变成局部变量。为了严格约束，必须使用<code>var</code>声明，提供了strict模式，此时在js文件的第一行写上<code>&#39;use strict&#39;</code>即可，这就要求任何变量的声明必须使用<code>var</code>声明，否则会报错<code>ReferenceError</code>，以后均会使用strict模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用strict模式</span></span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b=<span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">method();</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// 这里能够访问到变量b</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用strict模式，此时变量a与b的声明必须使用关键字，否则报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">method();</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// 这里报错，因为b作用域为method函数内</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>运算符</p>
<ol>
<li><p>逻辑运算符，与其它语言一样，支持&amp;&amp;、||、!，需要注意的是在js中true &amp;&amp; expression，其结果就是expression</p>
</li>
<li><p>比较运算符，支持&lt;、&gt;等</p>
<ol>
<li><p>需要注意的是判断相等可以使用==或者===。对于==，其会发生自动类型转换，对于===，其会首先判断类型是否一致，然后判断是否相等，所以建议使用===，更加严谨规范</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>==<span class="literal">false</span>;<span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>===<span class="literal">false</span>;<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要特别注意的是数值类型中的NaN，其与其他任何类型比较均不相等，包括它自己，只能用<code>isNaN()</code>进行判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span>===<span class="literal">NaN</span>;<span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>支持三元运算符</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>===<span class="number">2</span>?<span class="string">"相等"</span>:<span class="string">"不相等"</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>语句</p>
<ol>
<li>判断语句与java完全一致，比如<code>if,else,else if</code></li>
<li>循环语句的for、while与do while循环均与java一致<ol>
<li>它提供了for in循环，其用于遍历的是属性字段，包括对象的属性、数组的角标字符串，但不能遍历Map和Set <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#x3D;[1,2,3];</span><br><span class="line">for(item in p)&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ES6提供了iterable类型，比如Array、Map和Set都是iterable类型，注意普通的对象不是iterable类型，iterable类型支持for of循环，这个for of循环类似于java中的高级for循环，其迭代的是值，而不再是for in中的属性 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var item of arr)&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>函数</p>
<ol>
<li><p>js中使用<code>function</code>关键字定义函数，类似于go中的<code>func</code>一样，在js中函数也是对象，函数名即为函数变量，其指向函数对象，也支持匿名函数，其变量名称指向函数对象</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">---------------分割线---------------</span><br><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>js中的函数调用，不同于java与go，有三点不同，</p>
<ul>
<li><p>没有形参类型和返参类型，也不要求调用实参的数目与形参保持一致，可以传入任意个实参，或多或少甚至不传都是可以的，其不影响调用，当实参数目超过形参数目时，对于函数并无影响，当实参数目小于形参数目时，其未传值的形参其值为undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"12"</span>,<span class="string">"test"</span>);<span class="comment">// 12</span></span><br><span class="line">   <span class="built_in">parseInt</span>();<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数内部有个默认的arguments参数，类似于数组，函数内部可以通过该参数获取调用的实参列表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">method(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6支持可变参数，可变参数本身是个数组，当可变参数没有传递时，此时不为undefined，而是空数组[]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">x,...other</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,other)</span><br><span class="line">&#125;</span><br><span class="line">method(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);<span class="comment">// 10 [ 20, 30 ]</span></span><br><span class="line">method(<span class="number">10</span>);<span class="comment">// 10 []</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数在不显式使用<code>return</code>返回值时，其也会默认返回undefined</p>
</li>
</ul>
</li>
<li><p>js是弱类型语言，所以调用函数时传递任意类型实参均是可行的，在函数内可以通过<code>typeof</code>关键字判断形参变量的类型名称，对于数值类型包括NaN和Infinity返回”number”，对于布尔值返回”boolean”，对于字符串返回”string”，对于数组、null等对象，返回”object”，对于undefined返回”undefined”</p>
</li>
<li><p>这里讲述一个变量声明提升的<strong>坑</strong>，在java和go当中，所有的变量在使用时需要先声明后使用，但是在js中是允许先使用后声明，因为在js函数中，在使用<code>var</code>声明变量时，其会将函数体内的所有声明的变量全部提升到函数顶部，所以js才会出现先使用后声明的情况，但需要注意的是仅是声明提升，赋值并没有提升</p>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x=<span class="string">"hello "</span>+y;</span><br><span class="line">    <span class="keyword">var</span> y=<span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">---------------上述等价于下述-----------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x,y;<span class="comment">// 此时x,y为undefined</span></span><br><span class="line">    x=<span class="string">"hello "</span>+y;<span class="comment">// "hello undefined"</span></span><br><span class="line">    y=<span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y); </span><br><span class="line">&#125;</span><br><span class="line">method();<span class="comment">// hello undefined world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于函数内的变量声明全部提升到函数顶部，所以对于代码块内声明的变量，其作用域并不是代码块内，仍然是整个函数体内，所以在ES6引入了<code>let</code>关键字代替<code>var</code>，其不允许变量声明提升，相应的也就使得存在代码块作用域，另一个表示常量的关键字<code>const</code>也能表示语句块作用域，一般建议使用<code>let</code>和<code>const</code>，代替<code>var</code></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;<span class="comment">// 使用var使得变量i声明提升</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">method();<span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="string">"hello "</span>+y;<span class="comment">// 这里报错，不允许未声明先使用</span></span><br><span class="line">    <span class="keyword">let</span> y=<span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);<span class="comment">// 这里也会报错，无法访问到变量i</span></span><br><span class="line">&#125;</span><br><span class="line">method2();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在strict模式，在函数体内使用var定义的变量，其作用域仅限于函数内，在函数外定义的变量，其作用域为全局，但js全局作用域的本质是，在浏览器中默认为js提供了一个唯一的全局对象window，我们在函数外定义的变量，本质上都会绑定到window对象的属性，包括定义的函数，其函数名也作为变量绑定到window对象的属性，比如alert()方法，其实就是window.alert()</p>
</li>
<li><p>与其他语言一样，在访问变量包括普通变量或者函数变量时，会先从最小的作用域开始寻找，否则向上寻找直至全局作用域，不然就抛出<code>ReferenceError</code>错误。我们定义的全局变量默认都会绑定到window对象中，当需要定义同名的变量时，需要使用命名空间，js通过定义一个空对象即可实现命名空间，jquery和underScore库均是如此</p>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myspace=&#123;&#125;;</span><br><span class="line">myspace.a=<span class="number">3</span>;</span><br><span class="line">myspace.method=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定到对象的函数，我们一般都叫做这个对象的方法，所以在js中一切函数都是方法，全局作用域下的函数都是window对象的方法。这里讲述下this的两个<strong>坑</strong></p>
<ul>
<li>类似于java，在函数中可以使用this指针，this指向的是主调的对象，所以如果是不通过对象直接调用函数，this则指向window，因为此时就是window对象在调用该方法，由于这种特性容易出现错误，所以ECMA限制在strict模式下，此时的this指向undefined，方便提前暴露错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;<span class="comment">// 是否使用strict模式结果不同</span></span><br><span class="line"><span class="keyword">let</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    showNameInner:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"my name is "</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAgeOuter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"my age is "</span>+<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">p.showNameInner();<span class="comment">// my name is zhangsan</span></span><br><span class="line"><span class="keyword">let</span> showNameOuter=p.showNameInner;<span class="comment">// 这里是一个函数对象，没有发生调用</span></span><br><span class="line">showNameOuter();<span class="comment">// my name is undefined，在strict模式下报错，无法访问undefined的name属性</span></span><br><span class="line">showAgeOuter();<span class="comment">// my age is undefined，在strict模式下同样报错</span></span><br><span class="line">p.showAgeInner=showAgeOuter;</span><br><span class="line">p.showAgeInner();<span class="comment">// my age is 18</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当对象调用方法时其this指向的当前对象仅在函数内有效，对于嵌套的函数内的this还是指向window，在strict模式下就是undefined，这里可以用其他变量临时存储this指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;<span class="comment">// 是否使用strict模式结果不同</span></span><br><span class="line"><span class="keyword">let</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 返回undefined undefined，在strict模式下，直接报错</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that=<span class="keyword">this</span>;<span class="comment">// 这里使用that临时保存this指针</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(that.name,that.age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>由于this指向的不确定性，所以产生较多问题，但js支持函数对象通过调用apply()或者call()方法来为函数的this显式指向绑定的对象，其方法的第一个参数是绑定的对象，如果不需要可以写成null，后面就是调用的实参，apply方法与call方法的区别在于，apply方法需要将实参封装成数组来传递，call方法不需要。利用apply方法，可以动态地改变方法的行为，比如实现装饰模式</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    showNameInner:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"my name is "</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.showNameInner();<span class="comment">// my name is zhangsan</span></span><br><span class="line"><span class="keyword">let</span> showNameOuter=p.showNameInner;<span class="comment">// 这里是一个函数对象，没有发生调用</span></span><br><span class="line">showNameOuter.apply(p,[]);<span class="comment">// my name is zhangsan</span></span><br><span class="line">showNameOuter.call(p);<span class="comment">// 同上，只是传递实参的方式不同</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var old&#x3D;parseInt;</span><br><span class="line">var count&#x3D;0;</span><br><span class="line">parseInt&#x3D;function(x)&#123;</span><br><span class="line">    count+&#x3D;1;</span><br><span class="line">    return old.apply(null,[x]);</span><br><span class="line">&#125;</span><br><span class="line">parseInt(&quot;10&quot;);</span><br><span class="line">parseInt(&quot;20&quot;);</span><br><span class="line">parseInt(&quot;30&quot;);</span><br><span class="line">console.log(count);&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6支持解构赋值，顾名思义解开结构赋值，用于高效操作数据，其操作时需要保证两侧结构一致</p>
<ol>
<li>可以解构一个数组获取其值，但不同于go和python的简洁格式，js中需要有方括号，比如<code>var [a,b]=[&quot;hello&quot;,true]</code>，如果有层次嵌套，那么左侧同样要保持嵌套，比如<code>var [a,[b,c]]=[true,[&quot;zhangsan&quot;,2]]</code>，另外赋值时如果要忽略一些元素，可以直接不写部分变量，比如<code>var [x,,]=[1,2,3]</code></li>
<li>可以解构一个对象获取其值，其格式需要花括号，其中变量名称得与属性同名，由于需要避免花括号的歧义，所以左侧需要加上<code>var</code>关键字或者整体加上圆括号，另外这里也支持嵌套情况 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    age:<span class="number">10</span>,</span><br><span class="line">    gender:<span class="string">"male"</span>,</span><br><span class="line">    address:&#123;</span><br><span class="line">        city:<span class="string">"shanghai"</span>,</span><br><span class="line">        street:<span class="string">"no.1 street"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name,age,birth&#125;=p;</span><br><span class="line"><span class="keyword">var</span> &#123;name,...other&#125;=p; <span class="comment">// 此时另外两个属性会封装成对象传递给other</span></span><br><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">address</span>:&#123;city&#125;&#125;=p;<span class="comment">// 左侧的address不是变量，它只是为了获取右侧嵌套的address对象中的属性值</span></span><br></pre></td></tr></table></figure></li>
<li>在结构对象时，如果右侧不存在该属性则值为undefined，这里支持在解构时赋予默认值，另外也支持别名 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    age:<span class="number">10</span>,</span><br><span class="line">    gender:<span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">name</span>:myname,age&#125;=p;<span class="comment">// 注意name也不是变量，它是用于获取右侧name属性值给myname，这与上述的嵌套情况一致，使用冒号分隔</span></span><br><span class="line"><span class="keyword">var</span> &#123;name,age=<span class="number">12</span>,city=<span class="string">"shanghai"</span>&#125;=p;<span class="comment">// 这里12和"shanghai"就是默认值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>高阶函数</p>
<ol>
<li><p>高阶函数就是形参或返参为函数的函数，函数对象可以作为参数进行传递，这是实现函数式编程的前提，在go语言中函数也是一种类型也是能够作为形参和返参</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">a,f</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f(a));</span><br><span class="line">&#125;</span><br><span class="line">method(<span class="number">-2</span>,<span class="built_in">Math</span>.abs);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类似于java中stream的操作，js也支持类似的声明式编程，数组自身就直接支持一些高阶函数，比如forEach()、map()（其不同于forEach()会返回映射值）、every()（类似于allMatch()）、filter()、find()（类似于filter()与findFirst()结合体，返回第一个符合条件的元素）、findIndex()（同前，返回第一个符合条件的元素角标）、sort()（注意对于数值的排序是默认是将其转成字符串来排序）和reduce()</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">2</span>,<span class="number">10</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort());<span class="comment">// [ 10, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function">(<span class="params">v1,v2</span>)=&gt;</span>v1&lt;v2?<span class="number">-1</span>:<span class="number">1</span>));<span class="comment">// [ 2, 3, 10 ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类似于go，这里也支持自运行的函数，只需要在函数后使用圆括号提供实参即可，这里为了防止歧义需要加上圆括号，这与之前的解构赋值类似对于花括号一般都是要用圆括号围起来</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>高阶函数可以返回函数对象，如果返回的函数对象引用了局部变量，那么该函数就是闭包，简单来说，闭包就是函数+引用变量，就是携带状态的函数，而且其状态是私有的，对外界隐藏</p>
<ul>
<li>这里需要注意下返回的函数只是函数对象，其并没有立刻执行，其引用的变量只有在执行时才能确定下来</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 变量i声明提升，所以只有一个变量i，如果使用let则返回1,4,16</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">	          arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	              <span class="built_in">console</span>.log(i * i);</span><br><span class="line">	          &#125;);</span><br><span class="line">	      &#125;</span><br><span class="line">	      <span class="keyword">return</span> arr;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">let</span> arr = count();</span><br><span class="line">	  <span class="comment">// 此时i=4</span></span><br><span class="line">	  arr[<span class="number">0</span>]();<span class="comment">// 16</span></span><br><span class="line">	  arr[<span class="number">1</span>]();<span class="comment">// 16</span></span><br><span class="line">	  arr[<span class="number">2</span>]();<span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<pre><code>- 在诸如java和go这种面向对象的编程语言中，可以通过对象的私有变量来记录状态，而在ES6之前，对于js这种将函数作为一等公民的语言，只能通过闭包的形式来实现类似java对象私有变量的效果，其就是封装

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里形参x为了初始化闭包中的变量，类似于java中的初始化私有变量</span></span><br><span class="line">    <span class="keyword">let</span> count=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(++count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f=method(<span class="number">0</span>);<span class="comment">// 返回的函数f引用了局部变量count</span></span><br><span class="line">f();<span class="comment">// 1</span></span><br><span class="line">f();<span class="comment">// 2</span></span><br><span class="line">f();<span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> f2=method(<span class="number">10</span>);</span><br><span class="line">f2();<span class="comment">// 11</span></span><br><span class="line">f2();<span class="comment">// 12</span></span><br><span class="line">f2();<span class="comment">// 13</span></span><br></pre></td></tr></table></figure></code></pre><ol start="4">
<li><p>js支持箭头函数，其类似于java的lambda表达式，js本身就支持匿名函数，箭头函数就是简化的匿名函数，其与lambda表达式很相似，只有两点不同</p>
<ul>
<li><p>一个使用-&gt;，一个使用=&gt;</p>
</li>
<li><p><strong>箭头函数中的this指向是词法作用域，由上下文决定，并且在主调者明确的时候使用apply方法会自动忽略绑定的第一个对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=&#123;</span><br><span class="line">    name:<span class="string">"zhangsan"</span>,</span><br><span class="line">    showOld:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(that.name);<span class="comment">// zhangsan</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    showNew:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">// zhangsan</span></span><br><span class="line">    &#125;,</span><br><span class="line">    show:<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>.name),<span class="comment">// undefined</span></span><br><span class="line">    show2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);<span class="comment">// zhangsan </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.showOld()();</span><br><span class="line">p.showNew()();</span><br><span class="line">p.show();</span><br><span class="line">p.show2();</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>12. generator生成器
      1. js中的generator借鉴了python，生成器可以理解成是一个能够记住步骤状态可以多段返回的函数，其定义与普通函数类似，如下图所示。这里在调用时即`var a=gen(5)`，此时仅是创建出generator对象，还没有执行。执行它有两种方式，分别是生成器对象调用next()方法和使用for of循环迭代生成器对象。
      2. 使用next()方法，每次会返回一个对象，其格式为`{value: x, done: true/false}`，value属性表示yield或者return的值，done属性表示是否已经迭代完，如果done为true，此时对应的value就是return的值，再继续next()，返回的value就是undefined
      3. 使用for of迭代生成器对象，可以不需要自己判断done状态，其可以迭代所有的yield的value值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function* gen(x)&#123;</span><br><span class="line">    yield x+1;</span><br><span class="line">    yield x+2;</span><br><span class="line">    yield x+3;</span><br><span class="line">    return x+4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="7">
<li><p>对象综述</p>
<ol>
<li>对象的类型判断<ol>
<li>由于js是动态类型语言，所以对于接收到的一个变量，其类型是未知的，我们需要使用<code>typeof</code>关键字进行判断。这里首先要与java这种静态类型语言的对象类型做区分，在java中类型是显式的，每个对象的类型就是所属类型，并且根据继承实现关系，也属于所继承或实现的类型，直至Object类型。js是一门基于对象的语言，其所有实体都是对象，其对象也有类型区分，但不同于java这种区分方式，通过<code>typeof</code>关键字，其分为number类型、string类型、boolean类型、function类型和object类型五种对象，另外还有一种特殊的undefined类型，其中需要注意的是null、数组(无论是普通创建还是new方式)都是object类型，而undefined则需要特别注意的。这里如果要单独判断数组，可以用 <code>Array.isArray()</code>方法判断，单独判断null可以直接<code>x===null</code>判断</li>
<li>在js中对于普通的数据类型对象，也有包装类型，但不同于java这种将基本数据类型包装成对象类型，js其普通的数据类型已经是对象了，其包装类是将其转成object类型。对于boolean、number和string都可以通过包装类转成object类型，方式是通过new的方式，如下所示，注意包装后不仅类型发生变化，另外其与原有数据的比较，比如<code>new Number(123)===123</code>也是false，所以不建议使用包装类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123);</span><br><span class="line">new String(&quot;abc&quot;);</span><br><span class="line">new Boolean(true);</span><br></pre></td></tr></table></figure></li>
<li>另外还有同名不写new的转换函数，将任意类型的数据转成普通的数据类型，如下所示。其中的String()方法可以使用toString()代替，但是其不能用于null和undefined，另外对于普通的数值类型除去NaN和Infinity使用得加上圆括号或者加上点号，比如<code>(123).toString()</code>或者<code>123..toString()</code>，所以不如String()方法强大<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(&quot;123&quot;);&#x2F;&#x2F; 建议使用parseInt或parseFloat</span><br><span class="line">String(true);&#x2F;&#x2F; 可以将任意类型转成字符串，包括null，undefined等</span><br><span class="line">Boolean(&quot;true&quot;)&#x2F;&#x2F;返回true</span><br><span class="line">Boolean(&quot;false&quot;)&#x2F;&#x2F; 返回true，其仅仅根据是否是空串判断</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>常见库<ol>
<li>时间库，Date对象，new Date()获取当前时间，也可以输入时间参数指定时间，通过该对象可以获取到年月日时分秒与时间戳信息，注意js的月份与java有一样的问题。</li>
<li>正则表达式，正则表达式DSL的语法都是统一的，与java一样，创建正则表达式有两种方式，一种是使用正斜杠，另一种是new一个RegExp，如下所示。通过调用正则对象的test方法可以判断是否匹配，调用字符串对象的split方法进行分割字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var re1 &#x3D; &#x2F;ABC\-001&#x2F;;</span><br><span class="line">var re2 &#x3D; new RegExp(&#39;ABC\\-001&#39;);&#x2F;&#x2F;这里双反斜杠代替一个反斜杠</span><br></pre></td></tr></table></figure></li>
<li>json是js的一个子集，用于数据交换，其严格要求编码方案使用utf-8，字符串必须使用双引号，键必须是字符串，所以非常统一，js内置了JSON对象用于序列化和反序列化。使用JSON.stringify()方法进行序列化，其中第二个参数可以指定想要序列化的属性或者指定一个函数进行变换，另外也可以给对象新增一个toJSON方法，其返回一个自定义对象，供序列化；使用JSON.parse()方法进行反序列化，与java需要输入类型信息不同，这里通过输入json串直接返回一个对象</li>
</ol>
</li>
<li>面向对象<ol>
<li>在java等这种面向对象的编程语言中，是存在类与对象两种概念，类是模板，对象是类的实现，这样就构建出完备的继承实现体系。但是在js中没有类的概念，我们创建对象都是直接生成对象，并且通过prototype来实现类似继承的概念，从而可以进行代码复用</li>
<li>对于一个js对象，如果想要继承另一个对象，只需要将该对象的原型属性赋值为另一个对象，也就是让该对象的原型指向另一个对象即可，比如<code>xiaoming.__proto__=student</code>(注意这是一个属性，另外两边各有两个下划线)。一般不采用这种方式，而是通过Object.create()方法，此时传入一个原型对象参数，那么就能得到一个指向该原型对象的新对象，此时新对象就继承了原型对象，而这仅仅是通过指向原型对象来实现，相比java这种在类上通过extends的方式会比较轻盈</li>
<li>当访问一个对象的属性或者方法时，此时首先从当前对象本身寻找，如果没有找到则向其原型对象寻找，依次类推直至向上寻找到最终原型对象<code>Object.prototype</code>，再找不到就返回undefined，这就构成了一条通过指向实现的原型链。其实我们创建的每种对象，其都有默认的原型，包括Object.prototype对象的原型为null<ol>
<li>对于字符串，其原型就是String.prototype对象，””.<strong>proto</strong>===String.prototype，该原型对象里定义了很多字符串的操作方法</li>
<li>对于布尔值，true.<strong>proto</strong>==Boolean.prototype</li>
<li>对于数字，(12).<strong>proto</strong>===Number.prototype</li>
<li>对于函数，Math.abs.<strong>proto</strong>===Function.prototype，里面定义了诸如apply()等方法</li>
<li>对于数组，[].<strong>proto</strong>===Array.prototype，里面定义了很多数组操作的方法</li>
<li>对于普通的对象，({}).<strong>proto</strong>===Object.prototype</li>
</ol>
</li>
<li>js支持构造函数，其形式类似于普通的函数，里面使用this关键字进行字段赋值，调用时需要使用new，此时this就指向新创建的对象，如果还是直接调用，那就是普通函数，在strict模式下，this指向undefined，所以调用this的属性会报错，为了以示区分，建议构造函数大驼峰，普通函数小驼峰。</li>
<li>如下所示，<strong>通过new构造函数这种方式(建立原型联系)</strong>，使得xiaoming对象的原型就是Student的原型，即<code>xiaoming.__proto.__===Student.prototype</code>，另外原型对象中都有个constructor属性，顾名思义用于反向指向构造函数对象，此时可见构造函数对象与原型对象通过prototype和constructor属性相互引用。所以创建的对象(普通方式创建也一样)自然也会从其原型中继承一个constructor属性。注意xiaoming这种对象可没有继承到prototype属性。两张图方便理解，<a href="http://note.youdao.com/noteshare?id=239822c575bfd920410d89d517ecc7e1" target="_blank" rel="noopener">原理图</a>，理解该图时要明确红线指向表示<strong>proto</strong>属性引用，而对于原型对象比如Student.protype其本身是原型对象，其原型对象的原型则是Student.protype.<strong>proto</strong>，这里不能理解错乱<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.hello &#x3D; function () &#123;</span><br><span class="line">        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming&#x3D;new Student(&quot;xiaoming&quot;);</span><br><span class="line">var xiaohong&#x3D;new Student(&quot;xiaohong&quot;);</span><br><span class="line">xiaoming.__proto__&#x3D;&#x3D;&#x3D;Student.prototype;</span><br><span class="line">Object.getPrototypeOf(xiaoming) &#x3D;&#x3D;&#x3D; Student.prototype; &#x2F;&#x2F; 另一种格式</span><br><span class="line">xiaoming instanceof Student &#x2F;&#x2F;也是另一种格式</span><br><span class="line">Student.prototype.constructor&#x3D;&#x3D;Student;</span><br><span class="line">xiaoming.constructor&#x3D;&#x3D;&#x3D;Student;</span><br><span class="line">xiaoming.hello!&#x3D;&#x3D;xiaohong.hello;</span><br></pre></td></tr></table></figure></li>
<li>这里需要注意的是xiaoming和xiaohong两个对象中的hello函数对象，虽然代码相同，但是它们各自属于各自的对象中，这从代码中this.hello的this指向创建的对象就能得知，由于存在内存浪费，所以我们只需要把这种公共的函数提升到原型对象Student.prototype中，这样就能保留一份hello函数对象了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.hello&#x3D;function()&#123;</span><br><span class="line">    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming&#x3D;new Student(&quot;xiaoming&quot;);</span><br><span class="line">var xiaohong&#x3D;new Student(&quot;xiaohong&quot;);</span><br><span class="line">xiaoming.hello&#x3D;&#x3D;&#x3D;xiaohong.hello;</span><br></pre></td></tr></table></figure></li>
<li>以上介绍的String、Boolean、Number、Function、Array和Object，这些其实都是函数对象，通过在控制台上直接打印，他们会显示<code>ƒ String() { [native code] }</code>诸如此类的名称不同的native code信息，但对于普通的函数显式<code>ƒ say(){console.log(&quot;hello world&quot;);}</code>函数内容信息，这些函数对象中有个prototype属性，其指向的就是其函数对象对应的原型对象</li>
<li>之前介绍的继承，实际上还是无法实现像java这种完整的多级继承，比如说我有Student，但是我新建了一个PrimaryStudent，在函数内apply调用了Student方法，但此时new一个PrimaryStudent对象，其原型链中没有Student这一环，但是可以通过空函数来桥接实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分别传入父子两个函数对象，此时子函数创建的对象的原型还没有指向父函数的prototype</span><br><span class="line">function inherits(Child, Parent) &#123;</span><br><span class="line">    &#x2F;&#x2F; 新建一个空函数对象</span><br><span class="line">    var F &#x3D; function () &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 先让子函数的protype不再指向原有的Child原型对象了，改成new出的F，此时就会影响到使用子函数new出的对象的原型指向</span><br><span class="line">    Child.prototype &#x3D; new F();</span><br><span class="line">    &#x2F;&#x2F; F函数的protype指向到Parent函数的protype，不再指向到原有的F原型对象，此时就会影响导致new出的F对象的原型指向</span><br><span class="line">    F.prototype &#x3D; Parent.prototype;</span><br><span class="line">    &#x2F;&#x2F; 再让new出的F的constructor属性指向到Child中去，这样就能格式统一</span><br><span class="line">    Child.prototype.constructor &#x3D; Child;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 新增方法到子原型上，此时还是透明的</span><br><span class="line">PrimaryStudent.prototype.getGrade &#x3D; function () &#123;</span><br><span class="line">    return this.grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>前面可以指到使用new构造函数的方式，其代码量较大，而且公共方法还得单独抽出来比较分散，关键是类和实例混在一起比较乱，从ES6开始提供class关键字，使得js可以定义类，并且new对象更加方便，类似于java的类定义。另外前面所说的使用空函数实现继承，太过于复杂，这里也提供了extends关键字，用于拓展，其也一样类似于java继承。这些技术的本质也是语法糖，由js引擎帮我们实现原型链的生成。</li>
<li>class里面不用写function关键字，默认有个空参的constructor方法， 可以指定显示的具有参数的构造器方法；可以使用static定义静态属性；也可以定义静态方法。注意不能直接定义实例变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里是约定的构造函数名称</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里定义对象的属性字段</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 这里是方法，不需要function关键字，并且该方法是原型拥有的</span><br><span class="line">    hello() &#123;</span><br><span class="line">        alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    static Country&#x3D;&quot;china&quot;;</span><br><span class="line">    static showCountry()&#123;</span><br><span class="line">        console.log(Student.Country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PrimaryStudent extends Student &#123;</span><br><span class="line">    constructor(name, grade) &#123;</span><br><span class="line">        super(name); &#x2F;&#x2F; super调用父类的构造方法</span><br><span class="line">        this.grade &#x3D; grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myGrade() &#123;</span><br><span class="line">        alert(&#39;I am at grade &#39; + this.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3></li>
</ol>
</li>
</ol>
</li>
<li><p>浏览器的对象</p>
<ol>
<li>电脑端和手机端常见的浏览器就是chrome和safari浏览器，其内核均是webkit，chrome浏览器其拥有js解析引擎v8，其支持的js版本自动保持最新</li>
<li>浏览器中提供了一些常见的操作对象有window，它也是全局对象；navigator对象，用于获取浏览器自身的名称版本等信息；location对象，用于表示当前url，可以用其解析出主机端口等信息，还能重载与加载某URL；document对象，其表示html网页的dom树</li>
<li>dom是一棵树，对dom的操作就是对dom节点的操作，每个节点下还有子节点，所以对dom树的操作无非就是增删改查，获取某个dom节点的方法有getElementById()，这个可以唯一确定一个节点，getElementsByTagName()和getElementsByClassName()，它们俩会返回一组节点，获取一个子节点使用children属性，第一个子节点firstElementChild和最后一个子节点lastElementChild。另外还有selector语法。</li>
<li>修改dom节点的内容，可以通过innerHTML、innerText或者textContent属性进行修改与读取，其中innerHTML不会进行编码，后面两个可以，从而保证无法设置任何html标签，后面两个的区别仅在于读取时，textContext可以返回包括隐藏的元素。另外还能通过节点的style属性去操作color、fontSize等属性来改变样式</li>
<li>增加dom节点，此时可以通过appendChild()添加到子节点末尾和insertBefore()添加到指定子节点之前，如果是对已有节点的索引再添加，产生的效果就是移动，另外一种是新建一个节点，这里得使用createElement()添加指定标签的节点，然后设置一些id和innerText等参数</li>
<li>删除节点，父节点调用removeChild删除子节点，子节点可以通过parentElement获取父节点，另外需要注意删除集合这种动态操作的长度变化问题。</li>
<li>操作表单，表单里的input标签有很多的type，比如test、password、radio单选、checkbox多选、hidden隐藏，select标签是下拉框。<ol>
<li>获取值可以通过节点的value属性，但对于选择框，需要判断checked属性</li>
<li>设置值，也是通过value属性，对于选择框设置checked</li>
<li>提交表单，设置form标签的onSubmit属性，赋值一个带有return方法的字符串，格式为<code>return checkForm()</code>，然后书写一个返回为布尔值的checkForm()函数，用于验证，如果返回true提交，返回false不提交。</li>
<li>对于type=”file”的input标签用于上传文件，这里浏览器出于安全限制，不允许通过value属性设置值，也无法获取本地文件路径，但html5之后，js提供了File和FileReader两个更为强大的api，可以帮助处理文件数据。</li>
</ol>
</li>
</ol>
</li>
<li><p>AJAX</p>
<ol>
<li>ajax全称是Asynchronous JavaScript and XML，意思是使用js发送异步的http请求。在传统的web页面中，发送一个请求比如submit，此时浏览器就会刷新页面，直至返回进入新页面，也就是说一个http请求对应一个页面，这个过程就是同步的，此时也是全量刷新。而使用ajax可以做到发送一个异步的http请求，在返回数据后通过回调对部分页面进行刷新，对用户而言，当前页面不变而数据不断更新。</li>
<li>发送ajax请求，首先创建一个XMLHttpRequest对象，通过request的onreadystatechange属性设置回调函数，在回调函数书写回调的代码，首先会通过request.readyState===4和request.status===200判断响应是否成功，然后拿出request.responseText进行处理；其次调用request.open()，第一个参数指定请求方法，第二个参数指定URL地址；最后才是发送请求，调用request.send()，对于get请求，不需要参数，对于post请求，需要传入body作为参数</li>
<li>由于浏览器的同源策略限制，使得ajax发送请求的时候其url的域名必须与当前页面一致，不能请求跨域。常见的解决方式有架设一台同域的代理服务器进行转发，还有就是使用jsonp，其本质利用浏览器允许进行跨域引用js资源，最后就是在html5下使用CORS(Cross-Origin Resource Sharing)跨域资源共享技术<ol>
<li>这里客户端会发送http请求，其中需要发送Origin:本域，这里包含本域信息，然后浏览器接收到响应后会检查Access-Control-Allow-Origin是否有本域，如果没有则跨域失败</li>
<li>这里还需要区分跨域请求类型，如果是GET/POST/HEAD，其中POST的Content-type受限，称之为简单请求，此时可以直接发送ajax；如果是PUT/DELETE/POST/其他类型，此时POST的content-type可以是自定义的application/json等，这种称之为特殊请求，此时浏览器会预发送OPTIONS(preflight预检请求)，通过Access-Control-Request-Method头询问服务器是否可以使用该ajax即将要请求的方法，服务器则会通过响应中的Access-Control-Allow-Methods头告诉其支持的允许的请求方法，浏览器在根据返回才决定是否发送这个ajax请求</li>
</ol>
</li>
<li>js提供了与java的future类似的Promise，用于进行异步的同步与异步等操作，使其回调操作不会嵌套，形成LINQ链式风格。通过new一个Promise将函数封装起来，然后可以调用Promise的then和catch方法，这里封装的function，其第一个参数是成功的回调函数，第二个是失败的回调函数，分别对应着then和catch，当没有第二个参数时也是可以的。支持Promise.all()和Promise.race()等</li>
</ol>
</li>
<li><p>jquery</p>
<ol>
<li>jquery是js最常用的库，它的作用就是简化代码调用。目前使用jquery2版本，只需要在script标签里引入jquery库即可。jquery将功能都放在了jQuery变量中，该变量属于window的一个属性，并且该变量是一个函数对象，另外它有个别名$，也就是说<code>$===jQuery===window.jQuery</code></li>
<li>选择器<ol>
<li>使用jquery来查找dom节点，其返回的是jquery对象，其封装了多个dom节点对象，当没有寻找到时不会返回undefined，平常只需要面对jquery对象操作即可。获取dom的节点，可以通过get方法，将dom节点变成jquery对象$()就能获取</li>
<li>按照id寻找$(“#id”)，按照tag寻找$(“tag”)，按照class寻找$(“.red”)，按照属性查找$(“[name=email]”)或者$(“[items=’a b’]”)或者$(“[name^=icon]”)（这里需要加上方括号，另外如果属性值有空格需要加上引号，另外可以通过^或$指定前后缀），组合查找$(“input[name=email]”)或$(“tr.red”)（可以寻找出input标签下或者tr标签下），以及使用逗号分隔条件的并集查找$(“p,div”)或者$(“p.red,p.green”)，使用空格或者&gt;进行层级查找$(‘ul.lang li.lang-javascript’)或者$(‘ul.lang&gt;li.lang-javascript’)，两者的区别在于后一种要求父子节点是直属的。以上这些选择器选出的jquery对象还能进行过滤，其格式是加上冒号，比如$(‘ul.lang li:first-child’)，$(‘ul.lang li:nth-child(2)’)等，可以进行一些过滤</li>
<li>jquery对象支持很多类似array中的方法操作，让我们以函数式编程的思想来进行处理。使用find()方法，可以传入上面介绍的查询参数，能够获取jquery对象的子节点；通过parent()方法获取父节点，也可以传入参数，不满足就返回空的jquery对象；可以通过next()和prev()方法来获取同一层级的下一个或前一个对象，也可以传入参数查找；另外支持对于jquery对象进行filter、map、first、last和slice等方法的操作，需要注意的是this指向的是dom对象而不是jquery对象</li>
</ol>
</li>
<li>操作dom<ol>
<li>jquery拿到节点后就可以做增删改查，并且其跨平台，并提供了非常简单的操作体验。jquery的查看与设置方法为同一个，不传参数则是查询，输入参数则是设置。另外需要注意一个jquery对象可能封装多个dom对象，这里的很多操作都是遍历操作，作用在一组dom节点上。jquery对象的所有方法除去get方法都是返回jquery对象，可能是修改的可能是新建的，所以可以链式操作</li>
<li>读取和设置文本或者html文本，使用text()和html()方法</li>
<li>调用css()方法操作属性</li>
<li>hasClass()可以判断是否有某个class，addClass()可以添加一个class，removeClass()可以删除某个class</li>
<li>显示或隐藏dom节点，使用show()和hide()，而不需要自己显示操作display属性</li>
<li>attr()方法用于查询和设置属性，removeAttr()用于删除属性，与attr属性相近的是prop()方法，与其的不同之处在于判断勾选框这种checked属性的时候，prop返回布尔值，但也能使用<code>radio.is(&#39;:checked&#39;)</code>前面讲述的过滤器来操作</li>
<li>对于表单元素专门提供了val()方法用于快捷查询和设置value值</li>
<li>可以对window和document等对象转成jquery对象，调用width()和height()等方法</li>
<li>添加节点除了之前的通过html()方法外还可以使用append()方法在子节点末尾添加子节点，这里参数可以是html字符串，也可以是dom节点、jquery对象甚至函数对象，prepend()放在子节点最前，在同级节点之前或之后新增，使用before()或after()方法</li>
<li>删除节点使用remove()，即将该jquery对象封装的dom节点删除</li>
</ol>
</li>
<li>事件操作<ol>
<li>页面加载后，js代码执行完后，只能通过触发事件，来执行绑定在事件上的回调函数</li>
<li>常见的事件有鼠标的click、dbclick、hover等事件、键盘的keydown和keypress等事件、Dom获取焦点时的focus、失去焦点时的blur、input等标签内容改变时的change、提交表单时的submit和document页面加载完成的ready事件</li>
<li>使用on()方法来为jquery对象绑定一个事件，比如<code>a.on(&quot;click&quot;,function(){alert(&quot;hello&quot;)})</code>，一般直接调用事件方法名称即click()，比如<code>a.click(function(){alert(&quot;hello&quot;)})</code></li>
<li>ready事件常用于绑定一些初始化函数，格式为<code>$(document).ready()</code>，以及最简格式<code>$()</code>。所有的事件回调函数都可以接受一个事件Event对象，用于获取一些事件信息</li>
<li>取消绑定需要调用off()方法，这里需要传入事件名以及绑定时的函数对象，也可以如果只传入事件名，那么就将该事件全部取消，如果不传参数，那么取消该jquery对象的所有事件</li>
<li>事件必须由用户操作触发(甚至对于延迟调用的用户操作也不会触发事件)，如果是通过js代码改变值等方式不会触发，这时需要手动触发，比如<code>input.val(&quot;change&quot;);input.change()</code>，这时就会手动触发change事件</li>
</ol>
</li>
</ol>
</li>
<li><p>nodejs</p>
<ol>
<li>nodejs简单来说就是将js从浏览器搬到服务器，其解析引擎使用V8，语法使用ES6以上，由于js单线程特性，所以用js做IO，只能通过异步方式。使用node运行项目的时候，可以加上参数为所有的js文件运行开启严格模式即<code>node --use_strict xx.js</code></li>
<li>由于js本身不提供模块的概念，所以在浏览器中如果在多个js文件中使用了相同名称的全局变量，它们会相互影响，在nodejs中也是如此，但这里nodejs通过提供一个语法糖实现module的概念，从而使得在不同的模块下的变量和函数相互不影响，而这仅是借助于函数局部作用域的方式实现</li>
<li>首先模块用法，当定一个xx.js文件时，该文件就是一个模块，其名称就是xx，在js文件里我们可以声明我们想要公开的变量包括函数，其方式是通过module.exports属性来提供，如果仅是暴露一个变量，可以直接对该属性赋值，如果想要暴露多个变量，则需要添加键值对或者赋值一个对象。在引用该模块的文件中，使用require函数进行引入该模块，这里假设它们在同一级目录下，即<code>var m=require(&quot;./xx&quot;)</code>，此时实际上就等价于<code>var m=module.exports</code>，所以如果是直接赋值exports时，此时m就直接是该变量，否则就是一个对象，本质上来说不管变量和对象其实都是变量，一回事<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports&#x3D;sayHello;</span><br><span class="line">module.exports.name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">module.exports.greet&#x3D;sayHello;</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    name:&quot;zhangsan&quot;,</span><br><span class="line">    greet:sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这种实现模块化的方式叫做commonJS，其提供的语法糖在于module模块的提供与保存，比如下面这个就是xx.js文件在nodejs语法糖处理后的结果。注意我们在业务代码里如果使用exports直接赋值来公开变量，实际上返回的还是空对象，因为很明显这里是值传递，对形参变量重新赋值，就不再指向原有的空对象，也就无法操作同一个地址上的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 提供module变量，id用于标识模块名称，exports用于标识需要公开的变量，初始为空对象</span><br><span class="line">var module &#x3D; &#123;</span><br><span class="line">    id: &#39;xx&#39;,</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 使用load函数将业务代码封装起来并返回exports</span><br><span class="line">var load &#x3D; function (exports, module) &#123;</span><br><span class="line">    &#x2F;&#x2F; 自己需要写业务代码地方</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 会添加一个load函数返回，将module.exports返回</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 调用load函数，这里需要注意的是会传递exports和module，其实exports都是指向同一个空对象</span><br><span class="line">var exported &#x3D; load(module.exports, module);</span><br><span class="line">&#x2F;&#x2F; 由node负责存储该模块</span><br><span class="line">save(module, exported);</span><br></pre></td></tr></table></figure></li>
<li>ES6中引入export和import关键字和import函数。这种语法与其他现代语言的导入导出更加类似，也便于理解。<ol>
<li>export负责导出变量，包括普通变量和函数对象和class，并且允许在声明变量的时候直接导出，比如<code>export var year=2000</code>，也可以统一导出，比如<code>export {name,sayHello}</code>，注意这里需要加上花括号，另外在导出时可以使用as重命名，比如<code>export {name as myname,sayHello as greet}</code>，export需要写在模块顶层，位置不限。</li>
<li>import用于导入export的变量，import需要搭配from关键字，注意导入的是export的名称，另外导入也可以重命名，比如import {myname as iname,greet as igreet} from “./xx”。import还支持整体导入到一个对象里，比如<code>import * as other from &quot;./xx&quot;</code>。与export类似，import也必须放在模块顶层。</li>
<li>import是静态导入，而require是运行时导入，所以这里提供了类似的import()函数实现运行时加载</li>
</ol>
</li>
<li>js在es6中支持…展开运算符，可以用于数组和对象等，比如<code>var arr2=[...arr,1,2],var q={...p,female:&quot;xiong&quot;}</code><h3 id="工具概念"><a href="#工具概念" class="headerlink" title="工具概念"></a>工具概念</h3></li>
</ol>
</li>
<li><p>babel用于将ES6以上的语法编译成ES5版本的语法，从而让低版本的runtime也能执行代码，简单来说用来做向后兼容的。</p>
</li>
<li><p>npm是nodejs自带的包管理工具，类似于maven，很多普通操作命令都是在项目目录下使用，支持语义化版本，~表示不兼容的大版本，^表示次版本</p>
<ol>
<li>npm init用于初始化当前目录为一个npm管理的项目，并生成package.json文件，此时会要求输入一些本js项目的name、version、entry point等信息</li>
<li>npm install/remove/update [package][@version]  ，-g=-global表示是否是全局安装,-S=–save表示写入到dependencies文件(默认)，-D=–save-dev表示依赖写入到devDependencies参数中</li>
<li>npm run/test</li>
<li>npm config set registry xxx，用于设置npm镜像，默认仓库是<a href="http://registry.npmjs.org" target="_blank" rel="noopener">http://registry.npmjs.org</a></li>
<li>npm ls查看安装包</li>
<li>npm login登录，npm publish发布本地包</li>
<li>npm root [-g]，查看项目npm包安装路径和全局安装路径</li>
<li>npm view [package]，查看npm包信息</li>
<li>npm cache clean，清理本地缓存</li>
</ol>
</li>
<li><p>yarn类似于npm，也是一个js包管理工具，其会更新pakcage.json和yarn.lock文件</p>
<ol>
<li>yarn init</li>
<li>yarn add/remove/upgrade [package@version] [–dev]</li>
<li>yarn run/test</li>
</ol>
</li>
<li><p>ts是js的超集，在ts里可以直接写js代码，但ts提供了语法糖，可以使用强类型、接口和泛型等，但ts不能被js引擎直接运行，ts需要通过tsc编译成js代码，然后才能被js引擎执行。简单来说ts为js提供了编译期的type check，它就是一门静态类型语言，类似的语言有coffeescript、kotlin等。</p>
<blockquote>
<p>TypeScript is a syntactic sugar for JavaScript. </p>
</blockquote>
</li>
<li><p>less也是css的语法糖，也可以理解为js在样式表里的DSL，通过Less.js可以将less文件转成css文件，在less中可以使用变量、函数等语法特性，使得编写css样式比较简单</p>
<h3 id="chrome技巧"><a href="#chrome技巧" class="headerlink" title="chrome技巧"></a>chrome技巧</h3></li>
<li><p>在学习js语言时，可以直接使用chrome浏览器的console来执行js代码，其console可以上下切换执行过的语句，并且拥有语法提示功能，使用enter执行语句，使用shift+enter可以换行，功能强大，学习js必备</p>
</li>
<li><p>在pages目录下可以给tsx代码打断点进行调试</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.robotqi.cn/2020/05/05/javascript/" data-id="ckbdiqfio0000g4vwe1o8d4yq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript-node-js/" rel="tag">javascript/node.js</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/16/html%E6%95%99%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          html教程
        
      </div>
    </a>
  
  
    <a href="/2020/05/04/jvm%E5%86%85%E5%AD%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">jvm内存</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-xhtml-html5/" rel="tag">html/xhtml/html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript-node-js/" rel="tag">javascript/node.js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/html-xhtml-html5/" style="font-size: 10px;">html/xhtml/html5</a> <a href="/tags/javascript-node-js/" style="font-size: 10px;">javascript/node.js</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/13/html%E6%95%99%E7%A8%8B/">html教程</a>
          </li>
        
          <li>
            <a href="/2020/05/16/spring%E6%95%99%E7%A8%8B/">spring教程</a>
          </li>
        
          <li>
            <a href="/2020/05/16/html%E6%95%99%E7%A8%8B/">html教程</a>
          </li>
        
          <li>
            <a href="/2020/05/05/javascript/">javascript</a>
          </li>
        
          <li>
            <a href="/2020/05/04/jvm%E5%86%85%E5%AD%98/">jvm内存</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Robot Qi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>